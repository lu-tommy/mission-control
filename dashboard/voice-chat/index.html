<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ðŸ¦ž Larry Voice Chat</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: #e0e0e0;
      min-height: 100vh; 
      display: flex; 
      flex-direction: column;
    }
    
    /* Header */
    .header {
      display: flex; justify-content: space-between; align-items: center;
      padding: 16px 24px; 
      background: rgba(37, 37, 56, 0.95);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }
    .logo { font-size: 20px; font-weight: 600; }
    .header-right { display: flex; align-items: center; gap: 12px; }
    .status { 
      font-size: 13px; padding: 6px 14px; border-radius: 20px;
      display: flex; align-items: center; gap: 6px;
    }
    .status::before { 
      content: ''; width: 8px; height: 8px; border-radius: 50%;
      display: inline-block;
    }
    .status.connected { background: rgba(46, 160, 67, 0.2); color: #4ade80; }
    .status.connected::before { background: #4ade80; }
    .status.offline { background: rgba(239, 68, 68, 0.2); color: #f87171; }
    .status.offline::before { background: #f87171; }
    .status.connecting { background: rgba(245, 158, 11, 0.2); color: #fbbf24; }
    .status.connecting::before { background: #fbbf24; animation: blink 1s infinite; }
    @keyframes blink { 50% { opacity: 0.5; } }
    
    /* Mode Toggle */
    .mode-toggle {
      display: flex; gap: 4px; background: rgba(42, 42, 62, 0.8); 
      border-radius: 10px; padding: 4px;
    }
    .mode-btn {
      padding: 8px 16px; border-radius: 8px; cursor: pointer; 
      border: none; font-size: 13px; font-weight: 500;
      background: transparent; color: #888;
      transition: all 0.2s;
    }
    .mode-btn:hover { color: #fff; }
    .mode-btn.active { background: #3b82f6; color: white; }
    
    /* Chat Area */
    .chat {
      flex: 1; padding: 24px; overflow-y: auto;
      max-width: 800px; width: 100%; margin: 0 auto;
    }
    .message { 
      margin: 16px 0; display: flex; gap: 12px;
      animation: fadeIn 0.3s ease;
    }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } }
    .message.user { flex-direction: row-reverse; }
    .avatar { 
      width: 40px; height: 40px; border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      font-size: 22px; flex-shrink: 0;
    }
    .message.user .avatar { background: rgba(59, 130, 246, 0.3); }
    .message.larry .avatar { background: rgba(239, 68, 68, 0.2); }
    .bubble {
      background: rgba(42, 42, 62, 0.8); padding: 14px 18px; border-radius: 16px;
      max-width: 75%; line-height: 1.6; font-size: 15px;
    }
    .message.user .bubble { 
      background: linear-gradient(135deg, #3b82f6, #2563eb);
      border-bottom-right-radius: 4px;
    }
    .message.larry .bubble { 
      background: rgba(42, 42, 62, 0.9);
      border-bottom-left-radius: 4px;
    }
    
    /* Controls */
    .controls {
      padding: 20px 24px; 
      background: rgba(37, 37, 56, 0.95);
      backdrop-filter: blur(10px);
      border-top: 1px solid rgba(255,255,255,0.1);
    }
    .controls-inner {
      max-width: 800px; margin: 0 auto;
      display: flex; flex-direction: column; align-items: center; gap: 16px;
    }
    .transcript {
      min-height: 24px; text-align: center; color: #888; 
      font-style: italic; font-size: 14px;
    }
    .mic-container { display: flex; align-items: center; gap: 16px; }
    .mic-btn {
      width: 72px; height: 72px; border-radius: 50%; border: none;
      background: linear-gradient(135deg, #3b82f6, #2563eb);
      color: white; font-size: 28px; cursor: pointer;
      transition: all 0.2s; box-shadow: 0 4px 20px rgba(59, 130, 246, 0.4);
    }
    .mic-btn:hover { transform: scale(1.05); box-shadow: 0 6px 25px rgba(59, 130, 246, 0.5); }
    .mic-btn:active { transform: scale(0.95); }
    .mic-btn.listening { 
      background: linear-gradient(135deg, #ef4444, #dc2626);
      box-shadow: 0 4px 20px rgba(239, 68, 68, 0.5);
      animation: pulse 1.5s ease-in-out infinite;
    }
    .mic-btn.speaking {
      background: linear-gradient(135deg, #22c55e, #16a34a);
      box-shadow: 0 4px 20px rgba(34, 197, 94, 0.5);
    }
    @keyframes pulse {
      0%, 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4); }
      50% { box-shadow: 0 0 0 12px rgba(239, 68, 68, 0); }
    }
    .status-text {
      font-size: 12px; color: #666; text-align: center;
    }
    
    /* Empty State */
    .empty-state {
      text-align: center; padding: 60px 20px; color: #666;
    }
    .empty-state .icon { font-size: 48px; margin-bottom: 16px; }
    .empty-state h3 { font-size: 18px; color: #888; margin-bottom: 8px; }
    .empty-state p { font-size: 14px; }
  </style>
</head>
<body>
  <header class="header">
    <span class="logo">ðŸ¦ž Larry Voice</span>
    <div class="header-right">
      <div class="mode-toggle">
        <button class="mode-btn active" id="pushMode">ðŸŽ¯ Push</button>
        <button class="mode-btn" id="contMode">ðŸ”„ Continuous</button>
      </div>
      <span class="status connecting" id="status">Connecting</span>
    </div>
  </header>

  <div class="chat" id="chat">
    <div class="empty-state" id="emptyState">
      <div class="icon">ðŸŽ¤</div>
      <h3>Ready to chat</h3>
      <p>Click the mic or switch to Continuous mode</p>
    </div>
  </div>

  <div class="controls">
    <div class="controls-inner">
      <div class="transcript" id="transcript"></div>
      <div class="mic-container">
        <button class="mic-btn" id="micBtn">ðŸŽ¤</button>
      </div>
      <div class="status-text" id="statusText">Click mic to talk</div>
    </div>
  </div>

  <script>
    // ========== CONFIG ==========
    const API_URL = 'http://localhost:8889';
    const SILENCE_DELAY = 1500; // ms to wait before sending in continuous mode
    const RECONNECT_DELAY = 3000;
    const MAX_RETRIES = 3;

    // ========== STATE ==========
    let recognition = null;
    let isListening = false;
    let isSpeaking = false;
    let mode = localStorage.getItem('voiceMode') || 'push';
    let silenceTimer = null;
    let pendingText = '';
    let retryCount = 0;
    let apiConnected = false;

    // ========== DOM ==========
    const chat = document.getElementById('chat');
    const status = document.getElementById('status');
    const micBtn = document.getElementById('micBtn');
    const transcript = document.getElementById('transcript');
    const statusText = document.getElementById('statusText');
    const emptyState = document.getElementById('emptyState');
    const pushModeBtn = document.getElementById('pushMode');
    const contModeBtn = document.getElementById('contMode');

    // ========== INIT ==========
    async function init() {
      setStatus('connecting', 'Connecting...');
      await testConnection();
      setupRecognition();
      setMode(mode);
      log('Voice chat initialized');
    }

    // ========== CONNECTION ==========
    async function testConnection() {
      try {
        const r = await fetch(`${API_URL}/api/health`, { timeout: 5000 });
        const d = await r.json();
        if (d.status === 'ok') {
          apiConnected = true;
          retryCount = 0;
          setStatus('connected', 'Connected');
          return true;
        }
      } catch (e) {
        log('Connection failed: ' + e.message);
      }
      
      apiConnected = false;
      setStatus('offline', 'Offline');
      
      // Auto-retry
      if (retryCount < MAX_RETRIES) {
        retryCount++;
        log(`Retrying connection (${retryCount}/${MAX_RETRIES})...`);
        setTimeout(testConnection, RECONNECT_DELAY);
      }
      return false;
    }

    function setStatus(type, text) {
      status.className = 'status ' + type;
      status.textContent = text;
    }

    // ========== SPEECH RECOGNITION ==========
    function setupRecognition() {
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SR) {
        setStatus('offline', 'Speech not supported');
        statusText.textContent = 'Speech recognition not supported';
        return;
      }

      recognition = new SR();
      recognition.lang = 'en-US';
      recognition.interimResults = true;
      recognition.maxAlternatives = 1;

      recognition.onstart = () => {
        isListening = true;
        micBtn.classList.add('listening');
        micBtn.classList.remove('speaking');
        statusText.textContent = mode === 'continuous' ? 'Listening... (speak freely)' : 'Listening...';
        log('Recognition started');
      };

      recognition.onend = () => {
        isListening = false;
        micBtn.classList.remove('listening');
        log('Recognition ended');
        
        // In continuous mode, restart listening after speaking finishes
        if (mode === 'continuous' && !isSpeaking && apiConnected) {
          setTimeout(() => {
            if (mode === 'continuous' && !isListening && !isSpeaking) {
              startListening();
            }
          }, 500);
        } else if (mode === 'push') {
          statusText.textContent = 'Click mic to talk';
        }
      };

      recognition.onerror = (e) => {
        log('Recognition error: ' + e.error);
        isListening = false;
        micBtn.classList.remove('listening');
        
        if (e.error === 'no-speech') {
          statusText.textContent = 'No speech detected';
          // In continuous mode, restart
          if (mode === 'continuous') {
            setTimeout(startListening, 1000);
          }
        } else if (e.error === 'aborted') {
          // Normal stop, ignore
        } else {
          statusText.textContent = 'Error: ' + e.error;
        }
      };

      recognition.onresult = (e) => {
        const result = e.results[e.results.length - 1];
        const text = result[0].transcript.trim();
        
        if (!text) return;
        
        // Show live transcript
        transcript.textContent = text;
        pendingText = text;

        if (result.isFinal) {
          log('Final result: ' + text);
          
          if (mode === 'push') {
            // Push mode: send immediately on final
            sendMessage(text);
            transcript.textContent = '';
          } else {
            // Continuous mode: wait for silence then send
            clearTimeout(silenceTimer);
            silenceTimer = setTimeout(() => {
              if (pendingText && !isSpeaking) {
                sendMessage(pendingText);
                transcript.textContent = '';
                pendingText = '';
              }
            }, SILENCE_DELAY);
          }
        }
      };
    }

    function startListening() {
      if (!recognition || isListening || isSpeaking) return;
      
      try {
        recognition.continuous = (mode === 'continuous');
        recognition.start();
      } catch (e) {
        log('Start error: ' + e.message);
        // Already started, ignore
      }
    }

    function stopListening() {
      if (!recognition || !isListening) return;
      try {
        recognition.stop();
      } catch (e) {
        log('Stop error: ' + e.message);
      }
    }

    // ========== MODE ==========
    function setMode(newMode) {
      mode = newMode;
      localStorage.setItem('voiceMode', mode);
      
      pushModeBtn.classList.toggle('active', mode === 'push');
      contModeBtn.classList.toggle('active', mode === 'continuous');
      
      if (mode === 'continuous') {
        statusText.textContent = 'Continuous mode - listening...';
        if (!isListening && !isSpeaking && apiConnected) {
          startListening();
        }
      } else {
        statusText.textContent = 'Push mode - click mic to talk';
        stopListening();
      }
      
      log('Mode set: ' + mode);
    }

    pushModeBtn.addEventListener('click', () => setMode('push'));
    contModeBtn.addEventListener('click', () => setMode('continuous'));

    // ========== MIC BUTTON ==========
    micBtn.addEventListener('click', () => {
      if (!recognition) return;
      
      if (isSpeaking) {
        // Stop TTS if speaking
        speechSynthesis.cancel();
        isSpeaking = false;
        micBtn.classList.remove('speaking');
        statusText.textContent = 'TTS stopped';
        return;
      }
      
      if (isListening) {
        stopListening();
      } else {
        startListening();
      }
    });

    // ========== SEND MESSAGE ==========
    async function sendMessage(text) {
      if (!text.trim() || !apiConnected) return;
      
      clearTimeout(silenceTimer);
      stopListening();
      
      // Hide empty state
      emptyState.style.display = 'none';
      
      addMessage(text, 'user');
      statusText.textContent = 'Thinking...';

      try {
        const response = await fetch(`${API_URL}/api/chat`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ message: text })
        });

        const data = await response.json();

        if (data.response) {
          addMessage(data.response, 'larry');
          speak(data.response);
        } else if (data.error) {
          addMessage('Error: ' + data.error, 'error');
          statusText.textContent = 'Error occurred';
        }
      } catch (e) {
        log('Send error: ' + e.message);
        addMessage('Connection failed', 'error');
        statusText.textContent = 'Connection lost';
        testConnection();
      }
    }

    // ========== TTS ==========
    function speak(text) {
      if (!('speechSynthesis' in window)) {
        statusText.textContent = 'TTS not supported';
        resumeListeningAfterTTS();
        return;
      }

      speechSynthesis.cancel();
      
      const utterance = new SpeechSynthesisUtterance(text);
      utterance.rate = 1.0;
      utterance.pitch = 1.0;
      utterance.volume = 1.0;
      utterance.lang = 'en-US';

      utterance.onstart = () => {
        isSpeaking = true;
        micBtn.classList.add('speaking');
        micBtn.textContent = 'ðŸ”Š';
        statusText.textContent = 'Larry is speaking...';
        log('TTS started');
      };

      utterance.onend = () => {
        isSpeaking = false;
        micBtn.classList.remove('speaking');
        micBtn.textContent = 'ðŸŽ¤';
        log('TTS ended');
        resumeListeningAfterTTS();
      };

      utterance.onerror = (e) => {
        log('TTS error: ' + e.error);
        isSpeaking = false;
        micBtn.classList.remove('speaking');
        micBtn.textContent = 'ðŸŽ¤';
        statusText.textContent = 'TTS error';
        resumeListeningAfterTTS();
      };

      speechSynthesis.speak(utterance);
    }

    function resumeListeningAfterTTS() {
      if (mode === 'continuous' && apiConnected) {
        statusText.textContent = 'Your turn...';
        setTimeout(() => {
          if (!isListening && !isSpeaking) {
            startListening();
          }
        }, 500);
      } else {
        statusText.textContent = 'Click mic to talk';
      }
    }

    // ========== UI ==========
    function addMessage(text, sender) {
      const div = document.createElement('div');
      div.className = 'message ' + sender;
      const avatar = sender === 'larry' ? 'ðŸ¦ž' : 'ðŸ‘¤';
      div.innerHTML = `
        <div class="avatar">${avatar}</div>
        <div class="bubble">${escapeHtml(text)}</div>
      `;
      chat.appendChild(div);
      chat.scrollTop = chat.scrollHeight;
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function log(msg) {
      console.log('[VoiceChat]', new Date().toLocaleTimeString(), msg);
    }

    // ========== START ==========
    init();
  </script>
</body>
</html>
